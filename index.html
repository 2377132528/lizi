<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>ğŸ„ åœ£è¯èŠ‚ AR ç²’å­ç³»ç»Ÿ ğŸ…</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0c0c0c; font-family: 'Christmas', sans-serif; }
        
        /* è§†é¢‘èƒŒæ™¯ */
        #input-video {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* é•œåƒ */
            z-index: 0;
            opacity: 0.5; /* ç•¥å¾®é™ä½é€æ˜åº¦ï¼Œå¢å¼ºèŠ‚æ—¥æ°›å›´æ„Ÿ */
        }

        /* Three.js Canvas */
        canvas { position: fixed; top: 0; left: 0; z-index: 1; pointer-events: none; }

        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #e0f2f7; /* æ·¡è“è‰² */
            text-shadow: 0 0 5px rgba(0,0,0,0.8), 0 0 10px #ff6666; /* çº¢è‰²é˜´å½± */
            background: rgba(12, 12, 12, 0.4);
            padding: 15px 25px;
            border-radius: 15px;
            border: 2px solid #ff6666; /* åœ£è¯çº¢è¾¹æ¡† */
            box-shadow: 0 0 15px rgba(255,102,102,0.8);
        }
        h1 { margin: 0; font-size: 28px; color: #ff6666; letter-spacing: 2px; text-transform: uppercase; }
        .info { font-size: 16px; opacity: 0.9; margin-top: 8px; color: #a8dadc; }
        .highlight { color: #f2f7e0; font-weight: bold; } /* é›ªç™½è‰² */

        /* åŠ è½½æç¤º */
        #loading {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff6666; font-size: 24px; z-index: 20;
            background: rgba(0,0,0,0.8); padding: 25px 50px; border-radius: 12px;
            border: 2px solid #a8dadc; /* åœ£è¯è“è¾¹æ¡† */
            box-shadow: 0 0 20px rgba(168,218,220,0.8);
        }

        /* éŸ³ä¹æ’­æ”¾æŒ‰é’® (å¯é€‰) */
        #music-button {
            position: fixed; bottom: 20px; right: 20px; z-index: 10;
            background: rgba(255,102,102,0.8); /* åœ£è¯çº¢ */
            color: white;
            border: 2px solid #a8dadc;
            border-radius: 50%;
            width: 50px; height: 50px;
            display: flex; justify-content: center; align-items: center;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255,102,102,0.5);
            transition: all 0.3s ease;
        }
        #music-button:hover {
            background: #ff4d4d;
            box-shadow: 0 0 15px rgba(255,102,102,1);
        }

        /* è‡ªå®šä¹‰å­—ä½“ï¼ˆå¦‚æœéœ€è¦ï¼Œè¯·ç¡®ä¿å­—ä½“æ–‡ä»¶å·²å¯¼å…¥æˆ–é“¾æ¥ï¼‰ */
        /* @font-face {
            font-family: 'Christmas';
            src: url('path/to/ChristmasFont.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        } */
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <video id="input-video" playsinline></video>

    <div id="ui-layer">
        <h1>åœ£è¯èŠ‚ AR é­”æ³•</h1>
        <div class="info"><span class="highlight">ğŸ–ï¸ åŒæ‰‹å¼ åˆï¼š</span>æ§åˆ¶ç²’å­èšæ•£</div>
        <div class="info"><span class="highlight">âœ‹ æ‰‹åŠ¿ 5/2/1ï¼š</span>åˆ‡æ¢æ–‡å­— <span class="highlight">"æˆ‘" / "çˆ±" / "ä½ "</span></div>
        <div class="info"><span class="highlight">â˜ï¸ é£ŸæŒ‡æ‹¨åŠ¨ï¼š</span>æ‰“æ•£ç²’å­æ•ˆæœ</div>
        <div class="info" id="stats">ç²’å­æ•°: æ­£åœ¨åŠ è½½...</div>
    </div>

    <div id="loading">æ­£åœ¨å‡†å¤‡åœ£è¯é­”æ³•...</div>

    <div id="music-button">
        ğŸµ
    </div>
    <audio id="christmas-music" loop src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3"></audio>
    <script>
        // --- æ ¸å¿ƒé…ç½® ---
        const CONFIG = {
            maxParticles: 20000,    // ç²’å­æ€»é‡ä¸Šé™ (æ‰‹æœºç«¯é€‚åº¦ï¼ŒPCå¯æ›´é«˜)
            particleSize: 0.18,     // ç²’å­å°ºå¯¸
            textDepth: 8.0,         // æ–‡å­—åšåº¦
            textLayers: 10,         // åšåº¦å±‚æ•°
            colorBase: 0x00ffff,    // ç²’å­åŸºè‰²ï¼ˆå¯è°ƒä¸ºåœ£è¯è‰²å¦‚ 0xffd700 é‡‘è‰²ï¼‰
            textScale: 0.15,        // æ–‡å­—åœ¨3Dåœºæ™¯ä¸­çš„å¤§å° (0.15-0.25 è¾ƒå¥½)
            repelRadius: 6.0,       // æ‰‹æŒ‡æ‹¨åŠ¨èŒƒå›´
            repelForce: 3.5,        // æ‹¨åŠ¨åŠ›åº¦
            returnSpeed: 0.08,      // ç²’å­å›å½’é€Ÿåº¦
            opennessFactor: 20.0,   // æ‰‹æŒå¼ åˆå½±å“ç²’å­çš„å¼ºåº¦ (Zè½´æ‰©æ•£)
            christmasLightCount: 100, // åœ£è¯æ ‘å½©ç¯æ•°é‡
            christmasLightColors: [0xff0000, 0x00ff00, 0x0000ff, 0xffff00], // å½©ç¯é¢œè‰²
        };

        let scene, camera, renderer, particles;
        let posArr, velocityArr; 
        let targetPositions = []; 
        const shapeCache = {};
        let currentText = "æˆ‘"; // é»˜è®¤æ–‡å­—

        let hand1Pos = new THREE.Vector3(0,0,0);
        let hand2Pos = new THREE.Vector3(0,0,0);
        let handOpenness = 1.0; // 0 = ç´§ç¼©, 1 = æ­£å¸¸, >1 = æ‰©æ•£
        let isHand1Detected = false;
        let isHand2Detected = false;
        let vWidth, vHeight; // è§†å£å‚æ•°

        // åœ£è¯æ ‘ç›¸å…³
        let christmasTreeGroup;
        let christmasLights = [];

        function init() {
            // 1. Three.js åŸºç¡€è®¾ç½®
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 30; 
            camera.position.y = 5; // ç¨å¾®æŠ¬é«˜è§†è§’çœ‹åœ£è¯æ ‘

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            updateViewport();

            // ç¯å¢ƒå…‰
            scene.add(new THREE.AmbientLight(0x404040, 2.0)); // æŸ”å’Œçš„ç¯å¢ƒå…‰
            const pointLight = new THREE.PointLight(0xffffff, 1.5, 100);
            pointLight.position.set(0, 20, 10);
            scene.add(pointLight);

            // 2. åˆå§‹åŒ–ç²’å­æ± 
            const geometry = new THREE.BufferGeometry();
            posArr = new Float32Array(CONFIG.maxParticles * 3);
            velocityArr = new Float32Array(CONFIG.maxParticles * 3);
            const colors = new Float32Array(CONFIG.maxParticles * 3);

            for(let i=0; i<CONFIG.maxParticles; i++){
                posArr[i*3]   = (Math.random() - 0.5) * 50;
                posArr[i*3+1] = (Math.random() - 0.5) * 50;
                posArr[i*3+2] = (Math.random() - 0.5) * 5;
                
                const c = new THREE.Color(CONFIG.colorBase);
                c.offsetHSL(0, 0, (Math.random()-0.5)*0.2);
                colors[i*3] = c.r;
                colors[i*3+1] = c.g;
                colors[i*3+2] = c.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: CONFIG.particleSize,
                vertexColors: true, 
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // 3. é¢„ç”Ÿæˆæ–‡å­—æ•°æ®
            generateShapeData("æˆ‘");
            generateShapeData("çˆ±");
            generateShapeData("ä½ ");
            applyShape("æˆ‘");

            // 4. æ·»åŠ åœ£è¯èŠ‚å…ƒç´ 
            createChristmasScene();

            // 5. äº‹ä»¶ä¸å¾ªç¯
            window.addEventListener('resize', onResize);
            document.getElementById('music-button').addEventListener('click', toggleMusic);
            initMediaPipe();
            animate();
        }

        // --- åœ£è¯åœºæ™¯åˆ›å»º ---
        function createChristmasScene() {
            christmasTreeGroup = new THREE.Group();
            scene.add(christmasTreeGroup);

            // æ ‘å¹²
            const trunkGeometry = new THREE.CylinderGeometry(0.8, 1.2, 8, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = -2; // åŸ‹å…¥åœ°é¢
            christmasTreeGroup.add(trunk);

            // æ ‘å¶ (å¤šå±‚åœ†é”¥)
            const snowTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/crate.gif'); // ç”¨ä¸ªé€šç”¨çº¹ç†æ¨¡æ‹Ÿé›ª
            snowTexture.wrapS = snowTexture.wrapT = THREE.RepeatWrapping;
            snowTexture.repeat.set(4,4);

            const snowMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, map: snowTexture, roughness: 0.5, metalness: 0.1 }); // é›ªæè´¨

            for (let i = 0; i < 4; i++) {
                const coneGeometry = new THREE.ConeGeometry(8 - i * 1.5, 6, 16);
                const coneMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 + i*0x111111, roughness: 0.7, metalness: 0.2 }); // æ·±ç»¿è‰²
                const cone = new THREE.Mesh(coneGeometry, coneMaterial);
                cone.position.y = i * 4 - 3;
                christmasTreeGroup.add(cone);

                // åœ¨é¡¶éƒ¨æ·»åŠ é›ªå¸½
                if(i > 0) { // æœ€åº•ä¸‹é‚£å±‚ä¸åŠ é›ª
                    const snowCapGeometry = new THREE.SphereGeometry(8 - i * 1.5 + 0.5, 16, 8, 0, Math.PI * 2, 0, Math.PI / 3); // æ‰å¹³çš„é›ªå¸½
                    const snowCap = new THREE.Mesh(snowCapGeometry, snowMaterial);
                    snowCap.position.y = i * 4 - 3 + 3; // æ”¾åœ¨é”¥ä½“é¡¶éƒ¨
                    christmasTreeGroup.add(snowCap);
                }
            }

            // æ ‘é¡¶ä¹‹æ˜Ÿ
            const starShape = new THREE.Shape();
            starShape.moveTo(0, 1.5);
            starShape.lineTo(0.5, 0);
            starShape.lineTo(1.5, 0);
            starShape.lineTo(0.8, -0.5);
            starShape.lineTo(1.0, -1.5);
            starShape.lineTo(0, -1.0);
            starShape.lineTo(-1.0, -1.5);
            starShape.lineTo(-0.8, -0.5);
            starShape.lineTo(-1.5, 0);
            starShape.lineTo(-0.5, 0);
            starShape.lineTo(0, 1.5);
            const starGeometry = new THREE.ShapeGeometry(starShape);
            const starMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffd700, emissiveIntensity: 0.8 });
            const star = new THREE.Mesh(starGeometry, starMaterial);
            star.position.y = 15.5; // æ ‘é¡¶
            star.scale.set(1.5, 1.5, 1.5);
            christmasTreeGroup.add(star);


            // åœ£è¯å½©ç¯
            const lightGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            for(let i=0; i<CONFIG.christmasLightCount; i++){
                const color = CONFIG.christmasLightColors[Math.floor(Math.random() * CONFIG.christmasLightColors.length)];
                const lightMaterial = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8 });
                const light = new THREE.Mesh(lightGeometry, lightMaterial);

                // éšæœºæ”¾ç½®åœ¨æ ‘çš„å‘¨å›´
                const radius = Math.random() * 7 + 1; // 1-8 èŒƒå›´
                const height = Math.random() * 16 - 2; // -2åˆ°14çš„æ ‘é«˜
                const angle = Math.random() * Math.PI * 2;

                light.position.set(
                    Math.cos(angle) * radius * (1 - height/16), // è¶Šå¾€ä¸Šè¶Šçª„
                    height,
                    Math.sin(angle) * radius * (1 - height/16)
                );
                christmasTreeGroup.add(light);
                christmasLights.push(light);
            }

            christmasTreeGroup.position.set(20, 0, -10); // æ”¾ç½®åœ¨åœºæ™¯å³ä¾§åå

            // åœ°é¢é›ªåœ°
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0xe0f2f7, roughness: 0.8, metalness: 0.1 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -6.5;
            scene.add(ground);
        }

        // --- æ ¸å¿ƒï¼šç”Ÿæˆ 3D ç«‹ä½“æ–‡å­—ç‚¹äº‘ ---
        function generateShapeData(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 400; 
            canvas.width = size;
            canvas.height = size;

            ctx.fillStyle = '#000';
            ctx.fillRect(0,0,size,size);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 250px Arial'; // å­—ä½“æ›´å¤§
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, size/2, size/2);

            const data = ctx.getImageData(0,0,size,size).data;
            const points = [];
            const step = 2; // é‡‡æ ·æ­¥é•¿

            for(let y=0; y<size; y+=step){
                for(let x=0; x<size; x+=step){
                    if(data[(y*size+x)*4] > 128){
                        const baseX = (x - size/2) * CONFIG.textScale; 
                        const baseY = -(y - size/2) * CONFIG.textScale;

                        for(let l=0; l<CONFIG.textLayers; l++){
                            const zOffset = (l / CONFIG.textLayers) * CONFIG.textDepth - (CONFIG.textDepth/2);
                            const zJitter = (Math.random() - 0.5) * 0.5;

                            points.push({
                                x: baseX,
                                y: baseY,
                                z: zOffset + zJitter
                            });
                        }
                    }
                }
            }
            
            console.log(`æ–‡å­— "${text}" ç”Ÿæˆäº† ${points.length} ä¸ªç›®æ ‡ç‚¹`);
            shapeCache[text] = points;
        }

        function applyShape(text) {
            currentText = text;
            const points = shapeCache[text];
            targetPositions = points;
            
            document.getElementById('stats').innerText = `å½“å‰ç²’å­æ•°: ${Math.min(points.length, CONFIG.maxParticles)} (æœ€å¤§ ${CONFIG.maxParticles})`;
        }

        // --- ç‰©ç†ä¸æ¸²æŸ“å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            const totalTargetPoints = targetPositions.length;
            const activeParticles = CONFIG.maxParticles; 
            const samplingStep = totalTargetPoints / activeParticles; 

            for(let i=0; i < activeParticles; i++){
                const ix = i*3;
                const iy = i*3+1;
                const iz = i*3+2;

                const sampledIndex = Math.floor(i * samplingStep);
                const target = targetPositions[Math.min(sampledIndex, totalTargetPoints - 1)]; 

                let tx = target.x;
                let ty = target.y;
                let tz = target.z;

                // 1. åŒæ‰‹å¼ åˆæ§åˆ¶ç²’å­æ‰©æ•£
                // Zè½´çš„æ‰©æ•£ï¼Œè®©æ–‡å­—çœ‹èµ·æ¥æ›´â€œæ·±â€æˆ–æ›´â€œæ‰â€
                tx *= handOpenness;
                ty *= handOpenness;
                tz *= handOpenness * CONFIG.opennessFactor; // å½±å“Zè½´æ‰©æ•£å¼ºåº¦

                // 2. äº¤äº’é€»è¾‘ï¼šæ‰‹æŒ‡æ–¥åŠ›
                if(isHand1Detected) { // åªä½¿ç”¨ä¸€åªæ‰‹è¿›è¡Œæ‹¨åŠ¨ï¼Œå¦ä¸€åªæ‰‹å‚ä¸å¼ åˆè®¡ç®—
                    const dx = posArr[ix] - hand1Pos.x;
                    const dy = posArr[iy] - hand1Pos.y;
                    const dz = posArr[iz] - hand1Pos.z;
                    
                    const distSq = dx*dx + dy*dy + dz*dz*0.2; 

                    if(distSq < CONFIG.repelRadius * CONFIG.repelRadius){
                        const dist = Math.sqrt(distSq);
                        const force = (1 - dist/CONFIG.repelRadius) * CONFIG.repelForce;
                        
                        velocityArr[ix] += (dx/dist) * force;
                        velocityArr[iy] += (dy/dist) * force;
                        velocityArr[iz] += (dz/dist) * force * 2.0; 
                    }
                }

                // 3. ç‰©ç†è®¡ç®—ï¼šå›å½’åŠ› + é˜»å°¼
                velocityArr[ix] += (tx - posArr[ix]) * CONFIG.returnSpeed;
                velocityArr[iy] += (ty - posArr[iy]) * CONFIG.returnSpeed;
                velocityArr[iz] += (tz - posArr[iz]) * CONFIG.returnSpeed;

                velocityArr[ix] *= 0.85;
                velocityArr[iy] *= 0.85;
                velocityArr[iz] *= 0.85;

                posArr[ix] += velocityArr[ix];
                posArr[iy] += velocityArr[iy];
                posArr[iz] += velocityArr[iz];
            }

            particles.geometry.attributes.position.needsUpdate = true;
            
            // ç²’å­ç¾¤ç¼“æ…¢æ—‹è½¬
            particles.rotation.y = Math.sin(Date.now()*0.0005) * 0.1;
            particles.rotation.x = Math.sin(Date.now()*0.0003) * 0.05;

            // åœ£è¯æ ‘å½©ç¯é—ªçƒ
            const time = Date.now() * 0.005;
            christmasLights.forEach((light, index) => {
                light.material.opacity = 0.6 + Math.sin(time + index) * 0.4; // 0.2 - 1.0 ä¹‹é—´é—ªçƒ
            });
            
            renderer.render(scene, camera);
        }

        // --- MediaPipe æ‰‹åŠ¿ä¸åæ ‡æ˜ å°„ ---
        function initMediaPipe() {
            const video = document.getElementById('input-video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 2, // æ£€æµ‹ä¸¤åªæ‰‹
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(results => {
                isHand1Detected = false;
                isHand2Detected = false;
                handOpenness = 1.0; // æ¯æ¬¡é‡ç½®

                if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0){
                    // å¤„ç†ç¬¬ä¸€åªæ‰‹ï¼ˆç”¨äºæ‹¨åŠ¨å’Œè®¡æ•°ï¼‰
                    const lm1 = results.multiHandLandmarks[0];
                    isHand1Detected = true;
                    updateHandPosition(lm1[8], hand1Pos); // é£ŸæŒ‡æŒ‡å°–ç”¨äºæ‹¨åŠ¨

                    const fingersUp1 = [8,12,16,20].map(tip => lm1[tip].y < lm1[tip-2].y);
                    const thumbUp1 = lm1[4].x < lm1[3].x; // ç®€å•åˆ¤æ–­å³æ‰‹æ‹‡æŒ‡
                    const count1 = fingersUp1.filter(Boolean).length + (thumbUp1 ? 1 : 0);
                    
                    // åˆ‡æ¢æ–‡å­— (åªç”¨ç¬¬ä¸€åªæ‰‹çš„æ‰‹åŠ¿)
                    if(count1 === 5 && currentText !== "æˆ‘") applyShape("æˆ‘");
                    else if(count1 === 2 && currentText !== "çˆ±") applyShape("çˆ±");
                    else if(count1 === 1 && currentText !== "ä½ ") applyShape("ä½ ");

                    // å¦‚æœæ£€æµ‹åˆ°ç¬¬äºŒåªæ‰‹ï¼Œè®¡ç®—åŒæ‰‹å¼ åˆ
                    if(results.multiHandLandmarks.length > 1){
                        isHand2Detected = true;
                        const lm2 = results.multiHandLandmarks[1];
                        updateHandPosition(lm2[8], hand2Pos); // è®°å½•ç¬¬äºŒåªæ‰‹é£ŸæŒ‡

                        // è®¡ç®—åŒæ‰‹é£ŸæŒ‡å°–è·ç¦»ï¼Œä½œä¸ºå¼ åˆåº¦
                        const dist = hand1Pos.distanceTo(hand2Pos);
                        
                        // æ˜ å°„è·ç¦»åˆ° 0.5 (ç´§ç¼©) - 2.0 (å¼ å¼€)
                        const minHandsDist = 5; // å‡è®¾ä¸¤æ‰‹é è¿‘æ—¶çš„æœ€å°è·ç¦»
                        const maxHandsDist = 30; // å‡è®¾ä¸¤æ‰‹å¼ å¼€æ—¶çš„æœ€å¤§è·ç¦»
                        
                        let normalizedDist = (dist - minHandsDist) / (maxHandsDist - minHandsDist);
                        normalizedDist = Math.max(0, Math.min(1, normalizedDist)); // é’³åˆ¶åœ¨0-1

                        handOpenness = 0.5 + normalizedDist * 1.5; // 0.5 åˆ° 2.0
                    }

                } else {
                    isHand1Detected = false;
                    isHand2Detected = false;
                }
            });

            const cam = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 640, height: 480 
            });
            
            cam.start().then(() => {
                document.getElementById('loading').style.display = 'none';
            }).catch(error => {
                console.error("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥:", error); 
                document.getElementById('loading').innerText = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™å’Œ HTTPS ç¯å¢ƒã€‚";
            });
        }

        // è¾…åŠ©å‡½æ•°ï¼šå°† MediaPipe å½’ä¸€åŒ–åæ ‡æ˜ å°„åˆ° Three.js ä¸–ç•Œåæ ‡
        function updateHandPosition(lmPoint, targetVector) {
            const x = (1 - lmPoint.x) - 0.5; // é•œåƒ+å±…ä¸­
            const y = (1 - lmPoint.y) - 0.5;
            
            targetVector.set(
                x * vWidth, 
                y * vHeight, 
                (lmPoint.z * -10) // ç®€å•æ·±åº¦æ˜ å°„
            );
        }

        function updateViewport() {
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            vHeight = 2 * Math.tan(vFOV / 2) * camera.position.z;
            vWidth = vHeight * camera.aspect;
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateViewport();
        }

        // éŸ³ä¹æ’­æ”¾æ§åˆ¶
        function toggleMusic() {
            const music = document.getElementById('christmas-music');
            const button = document.getElementById('music-button');
            if (music.paused) {
                music.play();
                button.innerHTML = 'â¸ï¸';
            } else {
                music.pause();
                button.innerHTML = 'ğŸµ';
            }
        }

        init();
    </script>
</body>
</html>
