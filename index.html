<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>3D ç²’å­ AR ç³»ç»Ÿ (æœ€ç»ˆä¿®æ­£ç‰ˆ)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        
        /* è§†é¢‘å…¨å±èƒŒæ™¯ (é•œåƒç¿»è½¬) */
        #input-video {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            z-index: 0;
            opacity: 0.6; 
        }

        /* Canvas è¦†ç›–å±‚ */
        canvas { position: fixed; top: 0; left: 0; z-index: 1; pointer-events: none; }

        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #fff; font-family: sans-serif;
            text-shadow: 0 0 4px #000;
        }
        h1 { margin: 0; font-size: 24px; color: #00ffff; letter-spacing: 1px; }
        .info { font-size: 14px; opacity: 0.8; margin-top: 5px; }

        #loading {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffff; font-size: 20px; z-index: 20;
            background: rgba(0,0,0,0.8); padding: 20px 40px; border-radius: 8px;
            border: 1px solid #00ffff;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <video id="input-video" playsinline></video>

    <div id="ui-layer">
        <h1>AR 3D ç²’å­ç³»ç»Ÿ</h1>
        <div class="info">ğŸ–ï¸ æ‰‹åŠ¿ 1/2/3 åˆ‡æ¢æ–‡å­— | â˜ï¸ é£ŸæŒ‡æ‹¨åŠ¨ç²’å­</div>
        <div class="info" id="stats">ç²’å­æ•°: æ­£åœ¨è®¡ç®—...</div>
    </div>

    <div id="loading">æ­£åœ¨ç”Ÿæˆé«˜å¯†åº¦ç²’å­...</div>

    <script>
        // --- æ ¸å¿ƒé…ç½® ---
        const CONFIG = {
            maxParticles: 15000,  // å†æ¬¡å¢åŠ ç²’å­ä¸Šé™
            particleSize: 0.18,   // æé«˜å°ºå¯¸ç¡®ä¿å¯è§æ€§
            textDepth: 8.0,       // æ–‡å­—åšåº¦
            textLayers: 10,       // åšåº¦å±‚æ•°
            colorBase: 0x00ffff, 
            repelRadius: 6.0,     
            repelForce: 3.5,      
            returnSpeed: 0.08     
        };

        let scene, camera, renderer, particles;
        let posArr, velocityArr; 
        let targetPositions = []; 
        
        const shapeCache = {};
        let currentText = "H";

        let isHandDetected = false;
        let handPos = new THREE.Vector3(0,0,0);
        let vWidth, vHeight; // è§†å£å‚æ•°

        function init() {
            // 1. Three.js åŸºç¡€è®¾ç½®
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 30; 

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            updateViewport();

            // 2. åˆå§‹åŒ–ç²’å­æ± 
            const geometry = new THREE.BufferGeometry();
            posArr = new Float32Array(CONFIG.maxParticles * 3);
            velocityArr = new Float32Array(CONFIG.maxParticles * 3);
            const colors = new Float32Array(CONFIG.maxParticles * 3);

            // ã€å…³é”®ä¿®æ­£ã€‘åˆå§‹åŒ–ç²’å­åˆ°éšæœºä½ç½®ï¼Œç¡®ä¿åœ¨ç›¸æœºè¿‘å¤„
            for(let i=0; i<CONFIG.maxParticles; i++){
                posArr[i*3]   = (Math.random() - 0.5) * 50;
                posArr[i*3+1] = (Math.random() - 0.5) * 50;
                posArr[i*3+2] = (Math.random() - 0.5) * 5;
                
                const c = new THREE.Color(CONFIG.colorBase);
                c.offsetHSL(0, 0, (Math.random()-0.5)*0.2);
                colors[i*3] = c.r;
                colors[i*3+1] = c.g;
                colors[i*3+2] = c.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: CONFIG.particleSize,
                vertexColors: true, 
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // 3. é¢„ç”Ÿæˆæ–‡å­—æ•°æ®
            generateShapeData("H");
            generateShapeData("Hi");
            generateShapeData("AI");
            
            // åˆå§‹åº”ç”¨
            applyShape("H");

            // 4. äº‹ä»¶ä¸å¾ªç¯
            window.addEventListener('resize', onResize);
            initMediaPipe();
            animate();
        }

        // --- æ ¸å¿ƒï¼šç”Ÿæˆ 3D ç«‹ä½“æ–‡å­—ç‚¹äº‘ ---
        function generateShapeData(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 400; // æé«˜åˆ†è¾¨ç‡ï¼Œæ•è·æ›´å¤šç»†èŠ‚
            canvas.width = size;
            canvas.height = size;

            ctx.fillStyle = '#000';
            ctx.fillRect(0,0,size,size);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 200px Arial'; // å­—ä½“æ›´å¤§
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, size/2, size/2);

            const data = ctx.getImageData(0,0,size,size).data;
            const points = [];

            const step = 2; // é‡‡æ ·æ­¥é•¿

            for(let y=0; y<size; y+=step){
                for(let x=0; x<size; x+=step){
                    if(data[(y*size+x)*4] > 128){
                        const baseX = (x - size/2) * 0.1; // è°ƒæ•´ç¼©æ”¾
                        const baseY = -(y - size/2) * 0.1;

                        for(let l=0; l<CONFIG.textLayers; l++){
                            const zOffset = (l / CONFIG.textLayers) * CONFIG.textDepth - (CONFIG.textDepth/2);
                            const zJitter = (Math.random() - 0.5) * 0.5;

                            points.push({
                                x: baseX,
                                y: baseY,
                                z: zOffset + zJitter
                            });
                        }
                    }
                }
            }
            
            console.log(`æ–‡å­— "${text}" ç”Ÿæˆäº† ${points.length} ä¸ªç›®æ ‡ç‚¹`);
            shapeCache[text] = points;
        }

        function applyShape(text) {
            currentText = text;
            const points = shapeCache[text];
            targetPositions = points;
            
            document.getElementById('stats').innerText = `å½“å‰ç²’å­æ•°: ${Math.min(points.length, CONFIG.maxParticles)} (æœ€å¤§ ${CONFIG.maxParticles})`;
        }

        // --- ç‰©ç†ä¸æ¸²æŸ“å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            const activeCount = Math.min(targetPositions.length, CONFIG.maxParticles);
            
            for(let i=0; i<CONFIG.maxParticles; i++){
                const ix = i*3;
                const iy = i*3+1;
                const iz = i*3+2;

                if (i >= activeCount) {
                    // éšè—å¤šä½™ç²’å­
                    posArr[ix] = 9999;
                    continue; 
                }

                // 1. è·å–ç›®æ ‡ä½ç½®
                const target = targetPositions[i % targetPositions.length]; // å¾ªç¯ä½¿ç”¨ç›®æ ‡ç‚¹
                let tx = target.x;
                let ty = target.y;
                let tz = target.z;


                // 2. äº¤äº’é€»è¾‘ï¼šæ‰‹æŒ‡æ–¥åŠ›
                if(isHandDetected) {
                    const dx = posArr[ix] - handPos.x;
                    const dy = posArr[iy] - handPos.y;
                    const dz = posArr[iz] - handPos.z;
                    
                    const distSq = dx*dx + dy*dy + dz*dz*0.2; 

                    if(distSq < CONFIG.repelRadius * CONFIG.repelRadius){
                        const dist = Math.sqrt(distSq);
                        const force = (1 - dist/CONFIG.repelRadius) * CONFIG.repelForce;
                        
                        // æ–½åŠ æ–¥åŠ›ç»™é€Ÿåº¦
                        velocityArr[ix] += (dx/dist) * force;
                        velocityArr[iy] += (dy/dist) * force;
                        velocityArr[iz] += (dz/dist) * force * 2.0; 
                    }
                }

                // 3. ç‰©ç†è®¡ç®—ï¼šå›å½’åŠ› + é˜»å°¼
                velocityArr[ix] += (tx - posArr[ix]) * CONFIG.returnSpeed;
                velocityArr[iy] += (ty - posArr[iy]) * CONFIG.returnSpeed;
                velocityArr[iz] += (tz - posArr[iz]) * CONFIG.returnSpeed;

                // é˜»å°¼ (æ‘©æ“¦åŠ›)
                velocityArr[ix] *= 0.85;
                velocityArr[iy] *= 0.85;
                velocityArr[iz] *= 0.85;

                // æ›´æ–°ä½ç½®
                posArr[ix] += velocityArr[ix];
                posArr[iy] += velocityArr[iy];
                posArr[iz] += velocityArr[iz];
            }

            particles.geometry.attributes.position.needsUpdate = true;
            
            // ç¼“æ…¢æ—‹è½¬æ•´ä¸ªç²’å­ç¾¤ï¼Œå¢å¼º 3D è§‚å¯Ÿæ„Ÿ
            particles.rotation.y = Math.sin(Date.now()*0.0005) * 0.1;
            particles.rotation.x = Math.sin(Date.now()*0.0003) * 0.05;

            renderer.render(scene, camera);
        }

        // --- MediaPipe æ‰‹åŠ¿ä¸åæ ‡æ˜ å°„ ---
        function initMediaPipe() {
            const video = document.getElementById('input-video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(results => {
                if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0){
                    isHandDetected = true;
                    const lm = results.multiHandLandmarks[0];

                    // 1. æ‰‹æŒ‡è®¡æ•° (åˆ‡æ¢æ–‡å­—)
                    const fingers = [8,12,16,20].map(tip => lm[tip].y < lm[tip-2].y);
                    const count = fingers.filter(Boolean).length;

                    if(count === 1 && currentText !== "H") applyShape("H");
                    else if(count === 2 && currentText !== "Hi") applyShape("Hi");
                    else if(count >= 3 && currentText !== "AI") applyShape("AI");

                    // 2. è·å–é£ŸæŒ‡æŒ‡å°–ä½ç½®ç”¨äºæ‹¨åŠ¨
                    const x = (1 - lm[8].x) - 0.5; 
                    const y = (1 - lm[8].y) - 0.5;
                    
                    handPos.set(
                        x * vWidth, 
                        y * vHeight, 
                        (lm[8].z * -10)
                    );

                } else {
                    isHandDetected = false;
                }
            });

            const cam = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 640, height: 480 
            });
            
            cam.start().then(() => {
                document.getElementById('loading').style.display = 'none';
            });
        }

        function updateViewport() {
            // ã€å…³é”®ä¿®æ­£ã€‘ç¡®ä¿ç›¸æœºä¸è§†å£å¯¹é½
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            vHeight = 2 * Math.tan(vFOV / 2) * camera.position.z;
            vWidth = vHeight * camera.aspect;
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateViewport();
        }

        init();
    </script>
</body>

</html>
