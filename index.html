<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Christmas AR Particle Love</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Mountains+of+Christmas:wght@700&family=Noto+Sans+SC:wght@400;700&display=swap');

    body {
      margin: 0;
      overflow: hidden;
      background-color: #0d1b2a;
      font-family: 'Noto Sans SC', sans-serif;
    }

    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
    }

    #video-element {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 1;
      transform: scaleX(-1);
      /* Mirror the webcam */
      opacity: 0.8;
      /* Slight dim for better particle visibility */
      filter: contrast(1.1) brightness(0.6);
    }

    /* Festive UI Overlay */
    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 20px;
    }

    .christmas-text {
      font-family: 'Mountains of Christmas', cursive;
      text-shadow: 0 0 10px #ff0000, 0 0 20px #00ff00;
    }

    .glass-panel {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(8px);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      pointer-events: auto;
    }

    .loader {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #c0392b;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>

  <!-- Webcam Video -->
  <video id="video-element" playsinline></video>

  <!-- 3D Canvas -->
  <div id="canvas-container"></div>

  <!-- UI Overlay -->
  <div id="ui-layer">
    <!-- Header -->
    <div class="flex justify-between items-start">
      <div class="glass-panel p-4 text-white max-w-md">
        <h1 class="text-3xl christmas-text text-red-400 mb-2">Merry Christmas</h1>
        <p class="text-sm opacity-90 mb-2">üéÑ <b>ÊâãÂäøÊéßÂà∂ / Gesture Control:</b></p>
        <ul class="text-xs space-y-1 list-disc pl-4">
          <li>‚úã <b>5 Fingers:</b> ÊòæÁ§∫ "Êàë" (Show "I")</li>
          <li>‚úåÔ∏è <b>2 Fingers:</b> ÊòæÁ§∫ "Áà±" (Show "Love")</li>
          <li>‚òùÔ∏è <b>1 Finger:</b> ÊòæÁ§∫ "‰Ω†" (Show "You")</li>
          <li>‚úä <b>Default:</b> Âú£ËØûÊ†ë (Christmas Tree)</li>
        </ul>
        <p class="text-xs mt-2 text-yellow-300">üëã ÁßªÂä®ÊâãÊåáÊã®Âä®Á≤íÂ≠ê (Touch to scatter particles)</p>
      </div>

      <div id="loading-indicator" class="glass-panel p-3 flex items-center gap-3">
        <div class="loader"></div>
        <span class="text-white text-sm font-bold">Loading AI...</span>
      </div>
    </div>

    <!-- Debug/Status -->
    <div class="text-center pb-4">
      <div id="gesture-status"
        class="inline-block glass-panel px-6 py-2 text-white text-xl font-bold christmas-text animate-pulse">
        Waiting for Camera...
      </div>
    </div>
  </div>

  <!-- Libraries -->
  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

  <script>
    // --- 1. CONFIGURATION & STATE ---
    const config = {
      particleCount: 4000,
      particleSize: 0.15,
      scatterRadius: 2.0,
      scatterForce: 0.2,
      returnSpeed: 0.05,
      colors: {
        tree: [0x2d6a4f, 0x40916c, 0x52b788, 0xd8f3dc, 0xffd700, 0xc1121f], // Greens, Gold, Red
        text: [0xff99c8, 0xfcf6bd, 0xd0f4de, 0xa9def9] // Pastels for text
      }
    };

    const state = {
      currentGesture: 'tree', // tree, 5, 2, 1
      targetPoints: [],
      particles: [],
      handPosition: new THREE.Vector3(0, 0, 0),
      isHandDetected: false,
      scale: 1.0,
      snowflakes: []
    };

    // --- 2. THREE.JS SETUP ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    // No background color, let video show through

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 10;

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // Lighting (for the tree aesthetic mostly)
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xffaa00, 1, 50);
    pointLight.position.set(5, 5, 5);
    scene.add(pointLight);

    // --- 3. PARTICLE SYSTEM GENERATION ---

    // Helper: Generate points for a 3D Cone (Christmas Tree)
    function getTreePoints(count) {
      const points = [];
      for (let i = 0; i < count; i++) {
        // Cone parametric logic
        const height = 9; // Height of tree
        const y = Math.random() * height - (height / 2); // Center y
        const radiusAtY = ((height / 2) - y) * 0.4; // Taper towards top
        const angle = Math.random() * Math.PI * 2;
        const r = Math.sqrt(Math.random()) * radiusAtY; // Uniform distribution in circle

        const x = r * Math.cos(angle);
        const z = r * Math.sin(angle);

        // Add some "ornament" points that are slightly outside
        const isOrnament = Math.random() > 0.9;
        const color = isOrnament
          ? (Math.random() > 0.5 ? 0xc1121f : 0xffd700) // Red or Gold
          : config.colors.tree[Math.floor(Math.random() * 3)]; // Greens

        points.push({ x, y, z, color, originalX: x, originalY: y, originalZ: z });
      }
      return points;
    }

    // Helper: Generate points from 2D Text
    function getTextPoints(text, count) {
      // 1. Create a temporary 2D canvas
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const size = 256;
      canvas.width = size;
      canvas.height = size;

      // 2. Draw text
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, size, size);
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 180px "Noto Sans SC"';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, size / 2, size / 2);

      // 3. Scan for white pixels
      const imageData = ctx.getImageData(0, 0, size, size);
      const data = imageData.data;
      const validPixels = [];

      for (let y = 0; y < size; y += 2) {
        for (let x = 0; x < size; x += 2) {
          const index = (y * size + x) * 4;
          if (data[index] > 128) { // If pixel is bright
            validPixels.push({
              x: (x / size - 0.5) * 10, // Scale to world units
              y: -(y / size - 0.5) * 10, // Flip Y
              z: 0
            });
          }
        }
      }

      // 4. Map to required particle count
      const resultPoints = [];
      for (let i = 0; i < count; i++) {
        const pixel = validPixels[Math.floor(Math.random() * validPixels.length)] || { x: 0, y: 0, z: 0 };
        // Add depth jitter
        resultPoints.push({
          x: pixel.x,
          y: pixel.y,
          z: (Math.random() - 0.5) * 2, // 3D depth for text
          color: config.colors.text[Math.floor(Math.random() * config.colors.text.length)]
        });
      }
      return resultPoints;
    }

    // Pre-calculate Targets
    const shapes = {
      'tree': getTreePoints(config.particleCount),
      '5': getTextPoints("Êàë", config.particleCount),
      '2': getTextPoints("Áà±", config.particleCount),
      '1': getTextPoints("‰Ω†", config.particleCount)
    };

    // Create Particle Geometry
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(config.particleCount * 3);
    const colors = new Float32Array(config.particleCount * 3);
    const scales = new Float32Array(config.particleCount);

    // Initialize as Tree
    shapes.tree.forEach((p, i) => {
      positions[i * 3] = p.x;
      positions[i * 3 + 1] = p.y;
      positions[i * 3 + 2] = p.z;

      const color = new THREE.Color(p.color);
      colors[i * 3] = color.r;
      colors[i * 3 + 1] = color.g;
      colors[i * 3 + 2] = color.b;

      scales[i] = 1.0;
    });

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute('scale', new THREE.BufferAttribute(scales, 1));

    // Shader Material for Glowing Particles
    const material = new THREE.ShaderMaterial({
      uniforms: {
        color: { value: new THREE.Color(0xffffff) },
      },
      vertexShader: `
                attribute float scale;
                attribute vec3 color;
                varying vec3 vColor;
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                    gl_PointSize = scale * ( 150.0 / - mvPosition.z );
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
      fragmentShader: `
                varying vec3 vColor;
                void main() {
                    if ( length( gl_PointCoord - vec2( 0.5, 0.5 ) ) > 0.475 ) discard;
                    gl_FragColor = vec4( vColor, 1.0 );
                }
            `,
      transparent: true
    });

    const particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);

    // --- 4. SNOW SYSTEM ---
    const snowGeo = new THREE.BufferGeometry();
    const snowCount = 200;
    const snowPos = new Float32Array(snowCount * 3);
    const snowVel = []; // Velocities

    for (let i = 0; i < snowCount; i++) {
      snowPos[i * 3] = (Math.random() - 0.5) * 20;
      snowPos[i * 3 + 1] = Math.random() * 20 - 10;
      snowPos[i * 3 + 2] = (Math.random() - 0.5) * 10;
      snowVel.push({
        x: (Math.random() - 0.5) * 0.05,
        y: -(Math.random() * 0.05 + 0.02)
      });
    }
    snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
    const snowMat = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.2,
      transparent: true,
      opacity: 0.8
    });
    const snowSystem = new THREE.Points(snowGeo, snowMat);
    scene.add(snowSystem);

    // --- 5. INTERACTION LOGIC (MOUSE/HAND REPULSION) ---
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // Plane at z=0

    // Handle Mouse/Touch Input
    function onPointerMove(event) {
      // Calculate pointer position in normalized device coordinates (-1 to +1)
      let clientX, clientY;

      if (event.touches && event.touches.length > 0) {
        clientX = event.touches[0].clientX;
        clientY = event.touches[0].clientY;
      } else {
        clientX = event.clientX;
        clientY = event.clientY;
      }

      pointer.x = (clientX / window.innerWidth) * 2 - 1;
      pointer.y = - (clientY / window.innerHeight) * 2 + 1;

      // Project pointer to 3D space on z=0 plane
      raycaster.setFromCamera(pointer, camera);
      const target = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, target);
      if (target) {
        state.handPosition.copy(target);
        state.isHandDetected = true;
      }

      // Reset "hand detected" timeout to auto-hide effect
      clearTimeout(window.interactionTimeout);
      window.interactionTimeout = setTimeout(() => {
        state.isHandDetected = false;
      }, 500);
    }

    window.addEventListener('mousemove', onPointerMove);
    window.addEventListener('touchmove', onPointerMove);

    // --- 6. MEDIAPIPE HAND TRACKING ---
    const videoElement = document.getElementById('video-element');
    const loadingIndicator = document.getElementById('loading-indicator');
    const gestureStatus = document.getElementById('gesture-status');

    function onResults(results) {
      loadingIndicator.style.display = 'none';

      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];

        // 1. Detect Fingers for Gesture Switching
        const fingerCount = countFingers(landmarks);

        let newGesture = 'tree';
        let displayText = "Christmas Tree";

        if (fingerCount === 5) {
          newGesture = '5';
          displayText = "Êàë (I)";
        } else if (fingerCount === 2) {
          newGesture = '2';
          displayText = "Áà± (Love)";
        } else if (fingerCount === 1) {
          newGesture = '1';
          displayText = "‰Ω† (You)";
        }

        if (state.currentGesture !== newGesture) {
          state.currentGesture = newGesture;
          gestureStatus.innerText = displayText;
        }

        // 2. Hand Position for Physics (Map Index finger tip to 3D space)
        // Note: Video is mirrored, coordinates are 0-1
        const indexTip = landmarks[8];

        // Simple mapping: (0,0) top-left -> 3D coords
        // Since camera is at z=10, screen width ~14 units at z=0
        const x = (0.5 - indexTip.x) * 15;
        const y = (0.5 - indexTip.y) * 10;

        state.handPosition.set(x, y, 0);
        state.isHandDetected = true;

      } else {
        // No hands, maybe fallback to tree after delay
        // But keep physics if mouse is moving
      }
    }

    function countFingers(landmarks) {
      // Simple logic: Is finger tip higher (y value lower) than PIP joint?
      // Thumb is X-axis based check
      let count = 0;

      // Thumb (4 tip, 3 ip, 2 mcp) - check x distance relative to wrist
      // Simplified: Check if tip is extended away from palm
      if (landmarks[4].x < landmarks[3].x) count++; // Assuming right hand mirrored

      // Index (8 tip, 6 pip)
      if (landmarks[8].y < landmarks[6].y) count++;
      // Middle (12 tip, 10 pip)
      if (landmarks[12].y < landmarks[10].y) count++;
      // Ring (16 tip, 14 pip)
      if (landmarks[16].y < landmarks[14].y) count++;
      // Pinky (20 tip, 18 pip)
      if (landmarks[20].y < landmarks[18].y) count++;

      return count;
    }

    const hands = new Hands({
      locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
      }
    });

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    // Start Camera
    const cameraUtils = new Camera(videoElement, {
      onFrame: async () => {
        await hands.send({ image: videoElement });
      },
      width: 1280,
      height: 720
    });
    cameraUtils.start();


    // --- 7. MAIN ANIMATION LOOP ---
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      const time = clock.getElapsedTime();

      const positionsAttribute = geometry.attributes.position;
      const targetShape = shapes[state.currentGesture];

      // 1. Update Particles
      for (let i = 0; i < config.particleCount; i++) {
        // Current Position
        let px = positionsAttribute.getX(i);
        let py = positionsAttribute.getY(i);
        let pz = positionsAttribute.getZ(i);

        // Target Position (from shape definition)
        // Use Modulo to wrap around if target has fewer points than particles
        const targetIndex = i % targetShape.length;
        const tx = targetShape[targetIndex].x;
        const ty = targetShape[targetIndex].y;
        const tz = targetShape[targetIndex].z;

        // Color Morphing
        const targetColorHex = targetShape[targetIndex].color;
        const targetColor = new THREE.Color(targetColorHex);
        const currentColor = new THREE.Color().fromBufferAttribute(geometry.attributes.color, i);
        currentColor.lerp(targetColor, 0.05); // Smooth color transition
        geometry.attributes.color.setXYZ(i, currentColor.r, currentColor.g, currentColor.b);

        // Movement Logic:
        // Calculate vector to target
        let vx = (tx - px) * 0.05; // Base speed to target
        let vy = (ty - py) * 0.05;
        let vz = (tz - pz) * 0.05;

        // Add slight noise for "Twinkle" / Alive feel
        vx += (Math.random() - 0.5) * 0.01;
        vy += (Math.random() - 0.5) * 0.01;

        // INTERACTION: Repel from Hand/Mouse
        if (state.isHandDetected) {
          const dx = px - state.handPosition.x;
          const dy = py - state.handPosition.y;
          const dz = pz - state.handPosition.z; // Include Z for 3D feel
          const dist = Math.sqrt(dx * dx + dy * dy + dz * dz); // 3D distance

          if (dist < config.scatterRadius) {
            const force = (config.scatterRadius - dist) / config.scatterRadius;
            const repelX = (dx / dist) * force * 1.5;
            const repelY = (dy / dist) * force * 1.5;
            const repelZ = (dz / dist) * force * 1.5;

            vx += repelX;
            vy += repelY;
            vz += repelZ;
          }
        }

        // Apply Velocity
        positionsAttribute.setXYZ(i, px + vx, py + vy, pz + vz);

        // Twinkle Scale
        const scale = 1.0 + Math.sin(time * 5 + i) * 0.3;
        geometry.attributes.scale.setX(i, scale);
      }

      positionsAttribute.needsUpdate = true;
      geometry.attributes.color.needsUpdate = true;
      geometry.attributes.scale.needsUpdate = true;

      // 2. Update Snow
      const snowPosAttr = snowGeo.attributes.position;
      for (let i = 0; i < snowCount; i++) {
        let y = snowPosAttr.getY(i);
        y += snowVel[i].y;

        // Reset if falls below screen
        if (y < -10) {
          y = 10;
          snowPosAttr.setX(i, (Math.random() - 0.5) * 20);
        }

        snowPosAttr.setY(i, y);
        snowPosAttr.setX(i, snowPosAttr.getX(i) + Math.sin(time + i) * 0.01); // Sway
      }
      snowPosAttr.needsUpdate = true;

      // 3. Rotate Group slightly
      particleSystem.rotation.y = Math.sin(time * 0.2) * 0.1;

      renderer.render(scene, camera);
    }

    // Resize Handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start Loop
    animate();

  </script>
</body>

</html>
